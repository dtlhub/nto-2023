# funcs

_Author: [@y73n0k](https://github.com/y73n0k)_

> Я придумал хэш-функцию на булевых функциях и так в ней уверен, что готов предоставить интерактивное взаимодействие и свой захэшированный секрет!

## Решение

Дано несколько разных функций, но нас будет интересовать `f`, так как она вызывается в `hash`. Можно, конечно, проанализировать все функции и понять, что `h` - инверсия, `f3` - [xor](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D1%8E%D1%89%D0%B5%D0%B5_%C2%AB%D0%B8%D0%BB%D0%B8%C2%BB), `f1` - [стрелка Пирса](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B5%D0%BB%D0%BA%D0%B0_%D0%9F%D0%B8%D1%80%D1%81%D0%B0), `f2` - [штрих Шеффера](https://ru.wikipedia.org/wiki/%D0%A8%D1%82%D1%80%D0%B8%D1%85_%D0%A8%D0%B5%D1%84%D1%84%D0%B5%D1%80%D0%B0), а результат `f3(f1(a, b), f2(a, b))` на самом деле просто xor (см. Полином Жегалкина для функций).

А можно пойти простым путём: построить таблицу истинности `f` не задумываясь об остальных функциях. В результате получаем таблицу истинности совпадающую с таблицей истинности операции xor.
Поэтому можно восстановить ключ, зная исходное сообщение. 

Но во время исполнения функции `hash` ключ перемешивается, замечаем, что это зависит от первых 8 битов сообщения, то есть от первого байта сообщения. Зная, что формат флага `nto{...}`, меняем первые 8 бит захэшированного флага на биты символа `n` и отправляем на сервер. Таким образом ключ при применении операции xor на захэшированный флага восстановит его (кроме первого символа так как мы его поменяли).

[Решение](./writeup/solution.py)
