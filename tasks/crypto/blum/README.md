# blum

_Author: [@y73n0k](https://github.com/y73n0k)_

> Ещё одна криптосистема, основанная на сложности факторизации больших целых чисел...

## Решение

### TL;DR
Китайская теорема об остатках + брут по подсказкам => разложение N => sqrt по модулям $p, q, r$ + КТО => случайное секретное число $x_0$ => восстановленная последовательность $k$ + XOR => флаг
<br>[Решение](./writeup/solution.py)

### Полное решение

В файле представлена реализация [криптосистемы Блюма — Гольдвассер](https://en.wikipedia.org/wiki/Blum%E2%80%93Goldwasser_cryptosystem)

Её криптографическая стойкость эквивалентна стойкости RSA, поэтому дана подсказка в виде остатков от деления делителей $p$ и $q$ числа $N = pqr$ на числа $2,\dots,348$

Рассмотрим остатки числа $p$. Получаем систему:

$p \equiv r_1^1 \pmod{2} \\ p \equiv r_1^2 \pmod{3} \\ \vdots \\ p \equiv r_1^{347} \pmod{348}$


Для нахождения $p$ воспользуемся [китайской теоремой об остатках](https://en.wikipedia.org/wiki/Chinese_remainder_theorem). Она даст решение $p \equiv p^* \pmod{N^* = \text{lcm}(2,\dots,348)}$

Битовая длина $N^* = 493$, в  то время как битовая длина исходного числа $p = 512$.
<br>Поэтому придётся запустить процесс перебора такого числа $k$, что $p = p^* + k \cdot N^*$ при этом битовая длина $k = 512 - 493 = 19$
<br>Условие остановки: $N \equiv 0 \pmod{p}$
<br>Таким образом восстанавливаем $p$.

Аналогично находим $q$ и получаем $r = \frac{N}{pq}$

Для восстановления текста нужно научиться брать корень из числа $x$ по модулям $p, q, r$
<br>В функции `get_primes` видим, что простые числа сгенерированы так, что их остатки равны $257$ по модулю $512$.
<br>То есть
<br>$p \equiv 257 \pmod{512}\\ p - 257 \equiv 0 \pmod{512}\\ p + 255 \equiv 0 \pmod{512}$

Зная разложение числа $N = pqr$ будем искать значение $x_0$ по модулям $p, q, r$

Рассмотрим число $a = x_L^{\frac{p + 255}{512}} \pmod{p}$
<br>Возведём его в квадрат
<br>$a^2 \equiv x_L^{\frac{p+255}{256}} \equiv x_L^{\frac{p-1+256}{256}} \equiv x_L^{\frac{p-1}{256} + \frac{256}{256}} \equiv x_L^{\frac{p-1}{256} + 1} \equiv x_L^{\frac{p-1}{256}}\cdot x_L \pmod{p}
$

Заметим, что `x = pow(x, 2048, n)`, а значит порядок числа $x_L$ делит $\frac{p-1}{\gcd(p - 1, 2048)}$, а значит $x_L^{\frac{p-1}{256}} \equiv 1 \pmod{p}$

Таким образом:
<br>$a^2 \equiv x_L \pmod{p}$

Чтобы получить $x_0$ нужно из числа $x_L$ взять квадратный корень $L$ раз, где $L = \text{len}(\text{cs})$
<br>что эквивалентно
<br>$x_{0_p} \equiv x_L^{(\frac{p + 255}{512})^L} \pmod{p}$

Можно упростить вычисление, найдя:
$e_p \equiv (\frac{p + 255}{512})^L \pmod{p - 1}$

Тогда

$x_{0_p} \equiv x_L^{e_p} \pmod{p}$

Аналогично

$x_{0_q} \equiv x_L^{e_q} \pmod{q}\\ x_{0_r} \equiv x_L^{e_r} \pmod{r}$

Применив китайскую теорему об остатках на $x_{0_p}, x_{0_q}, x_{0_r}$, получаем "начальный источник" $x_0$, так как $\text{lcm}(p, q, r) = N$, а значение $x_0 < N$

Теперь запустив алгоритм шифрования с известными начальными параметрами на зашифрованном сообщении, восстанавливаем сообщение в силу [свойств](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D1%8E%D1%89%D0%B5%D0%B5_%C2%AB%D0%B8%D0%BB%D0%B8%C2%BB#%D0%A1%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0) оператора $\text{XOR}$.

[Решение](./writeup/solution.py)
