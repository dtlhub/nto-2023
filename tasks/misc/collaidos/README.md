# Коллайдос

_Author: [@LeKSuS-04](https://github.com/LeKSuS-04)_

> Программировать на C++ люблю очень сильно. Алгоритмы всякие, структуры данных. Обожаю просто. Даже приложение написал. Посмотришь?

## Решение

Изучив исходники таска, можно заметить, что его суть сводится к следующему:

- Мы предоставляем некоторый ввод программе `./collaidos`;
- Если исполнение программы занимает более 30 секунд, мы получаем флаг.

То есть, необходимо выполнить своего рода DoS этого маленького приложения.

Функционал этого приложения состоит в том, что пользователь вводит не более 30'000 строк вида `"username" "password"`. При этом на юзернеймы и пароли наложено ограничение -- обе строки должны подходить под регулярное выражение `[a-zA-Z0-9_\-.]{1,15}`. После окончания ввода происходит подсчет количества уникальных юзернеймов и количество уникальных паролей путем объединения всех строк одного типа в `unordered_set` и вызова метода `.size()`. После этого оба числа выводятся пользователю и программа завершается.

Уязвимым местом является подсчет количества уникальных строк каждого типа; а именно -- использование `unordered_set`-а при этом. Эта структура данных представляет из себя хеш-таблицу, вставка в которую обычно работает за O(1), то есть финальная сложность будет составлять O(n), где n -- количество аккаунтов. Однако, в худшем случае, одна вставка в хеш-таблицу работает за O(n). Если каждая вставка будет иметь такую сложность, то общая сложность подсчета будет составлять O(n \* n), что будет выполняться **заметно** дольше.

Достигается этот худший случай тогда, когда у элементов, вставляемых в хеш-таблицу одинаковый хеш. Для хеширования строчек в стандартной библиотеке C++ используется Murmur hash, конкретную реализацию [можно найти в открытом доступе](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/hash_bytes.cc#L138). Она является достаточно примитивной, что и позволяет разработать алгоритм для получения строчек с одинаковым хешом.

Рассмотрим функцию, разбив её на три (две) условных части:

```cpp
  size_t
  _Hash_bytes(const void* ptr, size_t len, size_t seed)
  {
    ///////////////////// PART 0
    static const size_t mul = (((size_t) 0xc6a4a793UL) << 32UL)
			      + (size_t) 0x5bd1e995UL;
    const char* const buf = static_cast<const char*>(ptr);
    /////////////////////
    
    ///////////////////// PART 1
    // Remove the bytes not divisible by the sizeof(size_t).  This
    // allows the main loop to process the data as 64-bit integers.
    const size_t len_aligned = len & ~(size_t)0x7;
    const char* const end = buf + len_aligned;
    size_t hash = seed ^ (len * mul);
    for (const char* p = buf; p != end; p += 8)
      {
	const size_t data = shift_mix(unaligned_load(p) * mul) * mul;
	hash ^= data;
	hash *= mul;
      }
    /////////////////////

    ///////////////////// PART 2
    if ((len & 0x7) != 0)
      {
	const size_t data = load_bytes(end, len & 0x7);
	hash ^= data;
    // goal_in_second_stage
	hash *= mul;
      }
    hash = shift_mix(hash) * mul;
    hash = shift_mix(hash);
    /////////////////////
    return hash;
  }
```

0. Часть с объявлением некоторых констант, не представляет из себя интереса
1. Цикл, последовательно обрабатывающий пачки по 8 байт. Так как в нашем случае строки не длиннее 15 символов, то на цикл можно внимания не обращать, так как в любом случае этот код исполнится ровно один раз.
2. Полностью инвертируемая; имея финальный хеш можно вычислить значение `hash` в момент `goal_in_second_stage`.

Пусть у нас есть некоторый хеш `h`, для которого мы хотим генерировать различные строки, такие, что `hash<string>{}(s) = h`. Представим строку `s` из 15 символов в виде префикса `s1` длинны 8 и суффикса `s2` длины 7. Пусть после первого этапа хеширования строка `s1` отразится в значение `first_stage_result`. Заметим, что старший байт этого значения будет находиться на том же месте и в `goal_in_second_stage`, так как `s2` не длиннее 7 байт. На основе этого уже можно сделать вывод о том, подходит ли нам строчка `s`. Если же старшие байты совпадают, остается только проверить, что строка `first_stage_result ^ goal_in_second_stage == s2`.

Таким образом, имея лишь первые восемь символов строки мы можем определить, возможно ли добавить к ней суффикс так, чтобы хеш от получившейся строки был равен `h`. Вероятность этого, в среднем, составляет:

```
>>> 1/256 * (65/256)**7
2.6575030645173284e-07
```

(Необходимо, чтобы старший байт `first_stage_result` совпал с таковым в `goal_in_second_stage`, а все 7 символов из `first_stage_result ^ goal_in_second_stage` входили в алфавит).

Получаем, что раз в ~2e-7 строк длины 8 мы получим такую, из которой можно будет получить строку, дающую желаемый хеш. Звучит вполне реально... Для одной строки. Но для решения задачи требуется около 30'000. При тестировании, автор несколько раз запустил программу `find_collisions` на своем ноутбуке, используя 4 потока и вычисляя 100 строк с одинаковым хешом. В среднем, получились такие результаты:

~ 30 секунд / 100 строк / 4 ядра => ~ 1.2 секунды / строку / ядро => ~ 10 часов / 30000 строк / кол-во ядер

То есть, для генерации 30000 строк с одинаковыми хешами потребуется около 10 часов процессорного времени.

Таким образом, таск можно было решить даже не используя несколько потоков, а просто оставив программу для поиска коллизий работать на ночь. С распределением же вычислений (на несколько ядер, или даже на несколько компьютеров своих тиммейтов) вычисления становятся не такими уж и страшными. Например, если предположить что у каждого участника в команде есть компьютер с хотя бы 4 ядрами процессора, вычислить финальный результат можно всего примерно за 40 минут.

После генерации такого файлика остается только его заслать. Для этого необходимо решить proof_of_work (подбор хешика с нужным префиксом в 3.5 байта спокойно брутфорсится даже на питоне) и отослать серверу ссылку на ввод для `collaidos`-а. Создать таковую можно, например, с помощью [gist.github.com](https://gist.github.com/).

Написанный автором вариант описанного выше алгоритма для поиска коллизий можно найти в директории [./sploit/find_collisions](./sploit/find_collisions/)

Скрипт на питоне, устанавливающий соединение с сервером, вычисляющий proof of work и отправляющий ссылку на ввод находится в [./sploit/sploit.py](./sploit/sploit.py)

Пример файлика, ввод которого в коллайдос решает таск, находится в [./sploit/payload.txt](./sploit/payload.txt).
